# Cursor Rules for CreatorSync Development

## Introduction

This document outlines the comprehensive rules and guidelines for using Cursor AI to develop the CreatorSync platform. Cursor is an AI-powered coding assistant that will be used to accelerate development while maintaining high code quality and consistency. These rules ensure that all code generated by Cursor adheres to our architectural principles, coding standards, and best practices.

## Table of Contents

1. [General Principles](#general-principles)
2. [Code Organization Rules](#code-organization-rules)
3. [Frontend Development Rules](#frontend-development-rules)
4. [Firebase Development Rules](#firebase-development-rules)
5. [Database Interaction Rules](#database-interaction-rules)
6. [API Development Rules](#api-development-rules)
7. [Testing Rules](#testing-rules)
8. [Security Rules](#security-rules)
9. [Performance Rules](#performance-rules)
10. [Documentation Rules](#documentation-rules)
11. [Workflow Integration](#workflow-integration)
12. [Troubleshooting Guide](#troubleshooting-guide)

## General Principles

### 1. Modularity First

- **Rule GP-1.1**: All code must be organized into small, focused modules with clear responsibilities.
- **Rule GP-1.2**: Each module should have a single responsibility and be loosely coupled with other modules.
- **Rule GP-1.3**: Use dependency injection patterns for managing service dependencies.
- **Rule GP-1.4**: Export only what is necessary from each module.

### 2. Type Safety

- **Rule GP-2.1**: All code must be written in TypeScript with strict type checking enabled.
- **Rule GP-2.2**: Avoid using `any` type; use proper type definitions or generics instead.
- **Rule GP-2.3**: Create and use interfaces for all data structures.
- **Rule GP-2.4**: Use union types and type guards for handling variable types.

### 3. Error Handling

- **Rule GP-3.1**: Implement comprehensive error handling for all operations that may fail.
- **Rule GP-3.2**: Use custom error classes that extend the base Error class.
- **Rule GP-3.3**: Include contextual information in error messages.
- **Rule GP-3.4**: Log errors with appropriate severity levels.
- **Rule GP-3.5**: Handle Firebase-specific errors with proper user feedback.

### 4. Naming Conventions

- **Rule GP-4.1**: Use descriptive, meaningful names for all variables, functions, and classes.
- **Rule GP-4.2**: Follow camelCase for variables and functions, PascalCase for classes and interfaces.
- **Rule GP-4.3**: Prefix interfaces with "I" (e.g., IUserService).
- **Rule GP-4.4**: Use verb prefixes for functions (e.g., getUserProfile, createPost).
- **Rule GP-4.5**: Use consistent naming for Firebase collections and documents.

### 5. Code Comments

- **Rule GP-5.1**: Include JSDoc comments for all public functions and classes.
- **Rule GP-5.2**: Explain "why" rather than "what" in comments.
- **Rule GP-5.3**: Keep comments up-to-date with code changes.
- **Rule GP-5.4**: Use TODO, FIXME, and NOTE tags with consistent formatting.
- **Rule GP-5.5**: Document Firebase operations with explanations of read/write implications.

## Code Organization Rules

### 1. Project Structure

- **Rule CO-1.1**: Organize code by feature rather than by type.
- **Rule CO-1.2**: Follow the established directory structure for Firebase-based applications:

```
src/
├── config/           # Firebase configuration
├── hooks/            # React hooks for Firebase integration
├── components/       # UI components organized by feature
│   ├── common/       # Shared UI components
│   ├── auth/         # Authentication components
│   ├── content/      # Content management components
│   └── [feature]/    # Feature-specific components
├── context/          # React context for state management
├── services/         # Firebase service abstractions
│   ├── auth.ts       # Authentication service
│   ├── firestore.ts  # Firestore data services
│   ├── storage.ts    # Firebase storage service
│   └── functions.ts  # Cloud functions service
├── models/           # TypeScript interfaces/types
├── utils/            # Utility functions
├── pages/            # Next.js pages (if using Next.js)
└── firebase/         # Firebase-specific utilities
    ├── rules/        # Firestore security rules
    ├── indexes/      # Firestore index definitions
    └── functions/    # Cloud Functions organized by domain
```

- **Rule CO-1.3**: Keep related files close to each other.
- **Rule CO-1.4**: Limit file size to 300 lines; split larger files into modules.
- **Rule CO-1.5**: Organize Cloud Functions by domain in separate files.

### 2. Import Organization

- **Rule CO-2.1**: Group imports in the following order:
  1. External libraries
  2. Firebase imports
  3. Internal modules
  4. Relative imports
  5. Type imports
- **Rule CO-2.2**: Sort imports alphabetically within each group.
- **Rule CO-2.3**: Use absolute imports for internal modules.
- **Rule CO-2.4**: Avoid circular dependencies.

### 3. Code Splitting

- **Rule CO-3.1**: Split large components into smaller, focused components.
- **Rule CO-3.2**: Use lazy loading for routes and large components.
- **Rule CO-3.3**: Implement code splitting at the route level.
- **Rule CO-3.4**: Extract reusable logic into custom hooks or utility functions.
- **Rule CO-3.5**: Create separate Firebase service modules for different domains.

### 4. Configuration Management

- **Rule CO-4.1**: Store all configuration in environment variables.
- **Rule CO-4.2**: Use a centralized configuration module to access Firebase config.
- **Rule CO-4.3**: Validate configuration values at startup.
- **Rule CO-4.4**: Provide sensible defaults for all configuration options.
- **Rule CO-4.5**: Keep Firebase project IDs and API keys in environment variables.

## Frontend Development Rules

### 1. Component Structure

- **Rule FE-1.1**: Follow the functional component pattern with hooks.
- **Rule FE-1.2**: Organize components using the following structure:

```tsx
// Imports
import React, { useState, useEffect } from 'react';
import { useFirestore, useFirestoreDocData } from 'reactfire';
import { Button } from '@/components/ui/button';

// Types
interface ContentCardProps {
  id: string;
  title: string;
  onAction: (id: string) => void;
}

/**
 * ContentCard displays a piece of content with title and expand/collapse functionality
 * 
 * @param id - Unique identifier for the content
 * @param title - The title of the content
 * @param onAction - Callback function triggered when the action button is clicked
 */
export const ContentCard: React.FC<ContentCardProps> = ({ 
  id, 
  title, 
  onAction 
}) => {
  // State hooks
  const [isExpanded, setIsExpanded] = useState(false);
  
  // Firebase hooks
  const contentRef = useFirestore().collection('content').doc(id);
  const { data: contentData } = useFirestoreDocData(contentRef);
  
  // Effect hooks
  useEffect(() => {
    // Log view event for analytics
    // This is done here rather than in a click handler to track impressions
    console.log(`Content viewed: ${id}`);
  }, [id]);
  
  // Event handlers
  const handleClick = () => {
    setIsExpanded(!isExpanded);
    onAction(id);
  };
  
  // Render
  return (
    <div className="rounded-lg p-4 bg-white shadow">
      <h3 className="text-lg font-medium">{title}</h3>
      {contentData?.description && isExpanded && (
        <p className="mt-2 text-gray-600">{contentData.description}</p>
      )}
      <Button onClick={handleClick}>
        {isExpanded ? 'Collapse' : 'Expand'}
      </Button>
    </div>
  );
};
```

- **Rule FE-1.3**: Extract complex logic into custom hooks.
- **Rule FE-1.4**: Keep components focused on UI concerns; move business logic to hooks or services.
- **Rule FE-1.5**: Create wrapper components around Firebase functionality for better testing and abstraction.

### 2. State Management

- **Rule FE-2.1**: Use React Query with Firebase SDK for server state management.
- **Rule FE-2.2**: Use React Context for global application state.
- **Rule FE-2.3**: Follow this decision tree for state management:
  1. Is it server data from Firebase? → React Query + Firebase SDK
  2. Is it authentication state? → Firebase Auth hooks + Context
  3. Is it global state needed across many components? → React Context
  4. Is it local component state? → useState/useReducer
- **Rule FE-2.4**: Create custom hooks for accessing Firebase data with proper loading/error states.

### 3. Styling

- **Rule FE-3.1**: Use Tailwind CSS for styling components.
- **Rule FE-3.2**: Follow utility-first approach with Tailwind.
- **Rule FE-3.3**: Extract common patterns into reusable components.
- **Rule FE-3.4**: Use CSS variables for theming and dynamic values.

### 4. Performance Optimization

- **Rule FE-4.1**: Memoize expensive calculations with useMemo.
- **Rule FE-4.2**: Memoize callback functions with useCallback.
- **Rule FE-4.3**: Use React.memo for components that render often but rarely change.
- **Rule FE-4.4**: Implement virtualization for long lists using react-window or react-virtualized.
- **Rule FE-4.5**: Optimize Firebase queries to limit document reads.

### 5. Accessibility

- **Rule FE-5.1**: Ensure all interactive elements are keyboard accessible.
- **Rule FE-5.2**: Use semantic HTML elements.
- **Rule FE-5.3**: Include proper ARIA attributes when necessary.
- **Rule FE-5.4**: Maintain sufficient color contrast ratios.

## Firebase Development Rules

### 1. Firebase Configuration

- **Rule FB-1.1**: Centralize Firebase configuration in a dedicated module.
- **Rule FB-1.2**: Initialize Firebase services only when needed.
- **Rule FB-1.3**: Use environment variables for Firebase project credentials.
- **Rule FB-1.4**: Implement different Firebase projects for development, staging, and production.
- **Rule FB-1.5**: Document Firebase service initialization and usage patterns.

### 2. Authentication

- **Rule FB-2.1**: Create a dedicated authentication service module.
- **Rule FB-2.2**: Implement custom hooks for authentication state and user profile data.
- **Rule FB-2.3**: Handle authentication errors with descriptive messages.
- **Rule FB-2.4**: Implement proper logout and session handling.
- **Rule FB-2.5**: Use Firebase Authentication to secure Cloud Functions.

### 3. Firestore Data Management

- **Rule FB-3.1**: Create service modules for each major data entity.
- **Rule FB-3.2**: Implement proper data validation before writing to Firestore.
- **Rule FB-3.3**: Use typed interfaces for all Firestore documents.
- **Rule FB-3.4**: Implement batch operations for multi-document updates.
- **Rule FB-3.5**: Document collection and document structure with comments.

### 4. Cloud Functions

- **Rule FB-4.1**: Organize Cloud Functions by domain in separate files.
- **Rule FB-4.2**: Implement proper error handling and logging in all functions.
- **Rule FB-4.3**: Validate input data at the beginning of each function.
- **Rule FB-4.4**: Keep functions focused on a single responsibility.
- **Rule FB-4.5**: Document function triggers, inputs, outputs, and potential costs.

### 5. Storage Management

- **Rule FB-5.1**: Create a dedicated storage service module.
- **Rule FB-5.2**: Implement file validation before upload.
- **Rule FB-5.3**: Use consistent folder structure for stored assets.
- **Rule FB-5.4**: Generate and store metadata for uploaded files.
- **Rule FB-5.5**: Implement proper error handling for upload/download operations.

## Database Interaction Rules

### 1. Data Access

- **Rule DB-1.1**: Create service abstractions around Firestore operations.
- **Rule DB-1.2**: Implement data access patterns with proper TypeScript typing.
- **Rule DB-1.3**: Use Firestore references consistently.
- **Rule DB-1.4**: Define clear interfaces for data access methods.

### 2. Schema Design

- **Rule DB-2.1**: Document collection schema in comments and/or separate files.
- **Rule DB-2.2**: Define TypeScript interfaces for all document types.
- **Rule DB-2.3**: Include indexed fields in interface documentation.
- **Rule DB-2.4**: Use appropriate data types for each field.
- **Rule DB-2.5**: Implement denormalization strategically to optimize reads.

### 3. Query Optimization

- **Rule DB-3.1**: Limit query results to minimize reads.
- **Rule DB-3.2**: Implement pagination for large collections.
- **Rule DB-3.3**: Create proper indexes for complex queries.
- **Rule DB-3.4**: Cache frequently accessed data.
- **Rule DB-3.5**: Document query complexity and read operations in comments.

### 4. Transactions

- **Rule DB-4.1**: Use transactions for operations that require atomicity.
- **Rule DB-4.2**: Implement proper error handling and rollback for transactions.
- **Rule DB-4.3**: Keep transactions as small as possible.
- **Rule DB-4.4**: Document transaction operations clearly.

### 5. Caching

- **Rule DB-5.1**: Implement client-side caching for frequently accessed data.
- **Rule DB-5.2**: Use React Query's caching capabilities.
- **Rule DB-5.3**: Implement TTL (Time To Live) for cached data.
- **Rule DB-5.4**: Invalidate caches appropriately when data changes.

## API Development Rules

### 1. Firebase Functions API Design

- **Rule API-1.1**: Organize Cloud Functions by domain and purpose.
- **Rule API-1.2**: Implement proper input validation for all functions.
- **Rule API-1.3**: Return consistent response formats.
- **Rule API-1.4**: Document function inputs, outputs, and error responses.

### 2. Error Handling

- **Rule API-2.1**: Return proper HTTP status codes for function errors.
- **Rule API-2.2**: Include descriptive error messages.
- **Rule API-2.3**: Log errors on the server side.
- **Rule API-2.4**: Implement retry logic for transient errors.

### 3. API Versioning

- **Rule API-3.1**: Include version in function names or paths.
- **Rule API-3.2**: Maintain backward compatibility within a version.
- **Rule API-3.3**: Document breaking changes between versions.
- **Rule API-3.4**: Deploy multiple versions simultaneously during transitions.

### 4. Request Validation

- **Rule API-4.1**: Validate all request inputs at the start of functions.
- **Rule API-4.2**: Use Joi or Zod for schema validation.
- **Rule API-4.3**: Return descriptive validation error messages.
- **Rule API-4.4**: Implement custom validators for complex validation rules.

### 5. Response Formatting

- **Rule API-5.1**: Use consistent response format across all functions.
- **Rule API-5.2**: Include pagination tokens in paginated responses.
- **Rule API-5.3**: Use camelCase for JSON property names.
- **Rule API-5.4**: Implement proper error response format.

## Testing Rules

### 1. Unit Testing

- **Rule TEST-1.1**: Write unit tests for all business logic.
- **Rule TEST-1.2**: Use Jest for unit testing.
- **Rule TEST-1.3**: Mock Firebase services in unit tests.
- **Rule TEST-1.4**: Aim for at least 80% code coverage.
- **Rule TEST-1.5**: Test both success and error scenarios.
- **Rule TEST-1.6**: Organize tests to mirror the source code structure.
- **Rule TEST-1.7**: Use descriptive test names that explain expected behavior.
- **Rule TEST-1.8**: Follow the Arrange-Act-Assert pattern.

### 2. Firebase Emulator Testing

- **Rule TEST-2.1**: Use Firebase Emulator Suite for integration testing.
- **Rule TEST-2.2**: Set up test fixtures for Firestore documents.
- **Rule TEST-2.3**: Test Firestore security rules with the Rules Playground.
- **Rule TEST-2.4**: Create automated tests for Cloud Functions using the emulator.
- **Rule TEST-2.5**: Test authentication flows with the Auth Emulator.
- **Rule TEST-2.6**: Implement automated setup and teardown for emulator tests.
- **Rule TEST-2.7**: Create seed data scripts for repeatable testing environments.
- **Rule TEST-2.8**: Test Firestore rules using @firebase/rules-unit-testing.

### 3. Component Testing

- **Rule TEST-3.1**: Test UI components with React Testing Library.
- **Rule TEST-3.2**: Focus on testing behavior rather than implementation.
- **Rule TEST-3.3**: Use user-centric queries (getByRole, getByLabelText, etc.).
- **Rule TEST-3.4**: Mock Firebase hooks in component tests.
- **Rule TEST-3.5**: Test accessibility with axe-core integration.
- **Rule TEST-3.6**: Use Storybook for component development and visual testing.
- **Rule TEST-3.7**: Implement Chromatic for visual regression testing.
- **Rule TEST-3.8**: Ensure components are responsive across different viewports.

### 4. End-to-End Testing

- **Rule TEST-4.1**: Implement E2E tests for critical user flows.
- **Rule TEST-4.2**: Use Cypress for E2E testing.
- **Rule TEST-4.3**: Run E2E tests in CI pipeline against emulators.
- **Rule TEST-4.4**: Use test data factories for consistent test data.
- **Rule TEST-4.5**: Record videos and screenshots of failed E2E tests.
- **Rule TEST-4.6**: Test cross-browser compatibility for critical features.
- **Rule TEST-4.7**: Implement user journey tests that reflect real user behavior.
- **Rule TEST-4.8**: Use custom Cypress commands for common workflows.

### 5. Test Automation

- **Rule TEST-5.1**: Configure GitHub Actions for automated test execution.
- **Rule TEST-5.2**: Run tests automatically on pull requests.
- **Rule TEST-5.3**: Set up parallel test execution for faster feedback.
- **Rule TEST-5.4**: Integrate test coverage reporting with Codecov.
- **Rule TEST-5.5**: Implement pre-commit hooks to run tests locally.
- **Rule TEST-5.6**: Configure test result reporting in PR comments.
- **Rule TEST-5.7**: Schedule nightly full test suite runs.
- **Rule TEST-5.8**: Implement test retries for flaky tests.

### 6. Test Data Management

- **Rule TEST-6.1**: Use factories for generating test data with Faker.js.
- **Rule TEST-6.2**: Implement test database seeding scripts.
- **Rule TEST-6.3**: Clean up test data after tests.
- **Rule TEST-6.4**: Use realistic test data that represents production scenarios.
- **Rule TEST-6.5**: Maintain a shared test fixtures directory.
- **Rule TEST-6.6**: Version test data alongside code.
- **Rule TEST-6.7**: Create specific test users with predefined roles and permissions.
- **Rule TEST-6.8**: Implement test data generators for various entity types.

### 7. Testing Standards

- **Rule TEST-7.1**: Write tests before or alongside implementation code.
- **Rule TEST-7.2**: Keep tests simple, focused, and fast.
- **Rule TEST-7.3**: Avoid testing implementation details.
- **Rule TEST-7.4**: Test edge cases and error handling.
- **Rule TEST-7.5**: Follow a consistent naming convention for test files.
- **Rule TEST-7.6**: Isolate tests to prevent dependencies between test cases.
- **Rule TEST-7.7**: Document complex test setups with comments.
- **Rule TEST-7.8**: Review test code with the same rigor as production code.

### 8. Performance Testing

- **Rule TEST-8.1**: Implement performance tests for critical operations.
- **Rule TEST-8.2**: Set performance baselines and thresholds.
- **Rule TEST-8.3**: Test Firebase query performance using emulators.
- **Rule TEST-8.4**: Monitor render performance with React DevTools.
- **Rule TEST-8.5**: Test application load time and time to interactive.
- **Rule TEST-8.6**: Implement bundle size monitoring.
- **Rule TEST-8.7**: Test Firestore operation latency.
- **Rule TEST-8.8**: Use Lighthouse CI for performance regression testing.

## Security Rules

### 1. Firebase Authentication

- **Rule SEC-1.1**: Implement proper user authentication flows.
- **Rule SEC-1.2**: Store tokens securely in local storage or cookies.
- **Rule SEC-1.3**: Implement token refresh mechanism.
- **Rule SEC-1.4**: Verify authentication state before accessing protected resources.

### 2. Firestore Security Rules

- **Rule SEC-2.1**: Implement comprehensive Firestore security rules.
- **Rule SEC-2.2**: Test security rules with the Rules Playground.
- **Rule SEC-2.3**: Implement role-based access control using custom claims.
- **Rule SEC-2.4**: Document security rule logic with comments.
- **Rule SEC-2.5**: Validate data integrity in security rules.

### 3. Data Protection

- **Rule SEC-3.1**: Never store sensitive data in client-side code.
- **Rule SEC-3.2**: Use Firebase Security Rules to protect data access.
- **Rule SEC-3.3**: Implement proper input sanitization.
- **Rule SEC-3.4**: Follow data minimization principles.

### 4. Firebase Functions Security

- **Rule SEC-4.1**: Implement authentication checks in Cloud Functions.
- **Rule SEC-4.2**: Validate all function inputs.
- **Rule SEC-4.3**: Set appropriate CORS headers for HTTP functions.
- **Rule SEC-4.4**: Implement rate limiting for public functions.

### 5. Storage Security

- **Rule SEC-5.1**: Implement proper Firebase Storage security rules.
- **Rule SEC-5.2**: Validate file types and sizes before upload.
- **Rule SEC-5.3**: Use signed URLs for temporary access to files.
- **Rule SEC-5.4**: Implement access control based on user roles.

## Performance Rules

### 1. Firebase Query Performance

- **Rule PERF-1.1**: Minimize Firestore reads and writes.
- **Rule PERF-1.2**: Implement pagination for large collections.
- **Rule PERF-1.3**: Create appropriate indexes for complex queries.
- **Rule PERF-1.4**: Document query performance considerations in comments.
- **Rule PERF-1.5**: Monitor and optimize queries that exceed free tier limits.

### 2. Frontend Performance

- **Rule PERF-2.1**: Minimize bundle size through code splitting.
- **Rule PERF-2.2**: Optimize images and assets.
- **Rule PERF-2.3**: Implement lazy loading for routes and components.
- **Rule PERF-2.4**: Use memoization for expensive calculations.
- **Rule PERF-2.5**: Implement efficient Firebase data listeners.

### 3. Cloud Functions Performance

- **Rule PERF-3.1**: Keep functions small and focused.
- **Rule PERF-3.2**: Optimize database operations within functions.
- **Rule PERF-3.3**: Set appropriate memory allocation.
- **Rule PERF-3.4**: Implement caching for expensive operations.
- **Rule PERF-3.5**: Use batched operations for multiple writes.

### 4. Offline Capabilities

- **Rule PERF-4.1**: Implement offline data persistence.
- **Rule PERF-4.2**: Handle offline/online state transitions gracefully.
- **Rule PERF-4.3**: Implement optimistic UI updates.
- **Rule PERF-4.4**: Queue operations for execution when online.

### 5. Monitoring

- **Rule PERF-5.1**: Use Firebase Performance Monitoring.
- **Rule PERF-5.2**: Set up alerts for performance degradation.
- **Rule PERF-5.3**: Monitor Firestore and function usage against free tier limits.
- **Rule PERF-5.4**: Conduct regular performance reviews.

## Documentation Rules

### 1. Code Documentation

- **Rule DOC-1.1**: Use JSDoc comments for all public functions and classes.
- **Rule DOC-1.2**: Include parameter and return type descriptions.
- **Rule DOC-1.3**: Document the purpose and usage of each component.
- **Rule DOC-1.4**: Document Firebase interactions and their implications.
- **Rule DOC-1.5**: Include examples for complex operations.

### 2. Firebase Documentation

- **Rule DOC-2.1**: Document Firestore collection and document structures.
- **Rule DOC-2.2**: Document security rule logic and access patterns.
- **Rule DOC-2.3**: Document Cloud Function triggers and purposes.
- **Rule DOC-2.4**: Document Firebase configuration and initialization.
- **Rule DOC-2.5**: Include documentation about potential costs and limitations.

### 3. API Documentation

- **Rule DOC-3.1**: Document all Cloud Functions with input/output specifications.
- **Rule DOC-3.2**: Include error response documentation.
- **Rule DOC-3.3**: Document authentication requirements.
- **Rule DOC-3.4**: Provide usage examples.

### 4. README Documentation

- **Rule DOC-4.1**: Maintain a comprehensive README with setup instructions.
- **Rule DOC-4.2**: Document environment variables and configuration.
- **Rule DOC-4.3**: Include development workflow instructions.
- **Rule DOC-4.4**: Document testing procedures.
- **Rule DOC-4.5**: Include troubleshooting information.

### 5. Comments

- **Rule DOC-5.1**: Use comments to explain complex logic.
- **Rule DOC-5.2**: Document performance considerations in comments.
- **Rule DOC-5.3**: Include references to relevant documentation or issues.
- **Rule DOC-5.4**: Use TODO comments with consistent formatting.
- **Rule DOC-5.5**: Explain "why" rather than "what" in comments.

## Workflow Integration

### 1. Version Control

- **Rule FLOW-1.1**: Use feature branches for development.
- **Rule FLOW-1.2**: Write descriptive commit messages.
- **Rule FLOW-1.3**: Use pull requests for code review.
- **Rule FLOW-1.4**: Keep commits focused and atomic.

### 2. CI/CD Integration

- **Rule FLOW-2.1**: Implement GitHub Actions for CI/CD.
- **Rule FLOW-2.2**: Run tests and linting in CI pipeline.
- **Rule FLOW-2.3**: Deploy to Firebase using GitHub Actions.
- **Rule FLOW-2.4**: Use preview channels for feature branches.

### 3. Environment Management

- **Rule FLOW-3.1**: Maintain separate Firebase projects for development, staging, and production.
- **Rule FLOW-3.2**: Use environment-specific configuration files.
- **Rule FLOW-3.3**: Document environment setup procedures.
- **Rule FLOW-3.4**: Implement proper secret management.

### 4. Collaboration

- **Rule FLOW-4.1**: Use GitHub issues for task tracking.
- **Rule FLOW-4.2**: Conduct code reviews for all changes.
- **Rule FLOW-4.3**: Document architectural decisions.
- **Rule FLOW-4.4**: Maintain a changelog.

## Troubleshooting Guide

### 1. Common Firebase Issues

- **Rule TROUBL-1.1**: Document common Firebase authentication issues and solutions.
- **Rule TROUBL-1.2**: Create a guide for debugging Firestore permission issues.
- **Rule TROUBL-1.3**: Document Cloud Function deployment and execution issues.
- **Rule TROUBL-1.4**: Create a checklist for security rule problems.

### 2. Development Environment Issues

- **Rule TROUBL-2.1**: Document Firebase Emulator Suite setup and usage.
- **Rule TROUBL-2.2**: Create debugging guides for common local development issues.
- **Rule TROUBL-2.3**: Document environment configuration troubleshooting.
- **Rule TROUBL-2.4**: Create solutions for common build errors.

### 3. Performance Troubleshooting

- **Rule TROUBL-3.1**: Document how to identify and fix slow Firebase queries.
- **Rule TROUBL-3.2**: Create a guide for optimizing Cloud Function performance.
- **Rule TROUBL-3.3**: Document strategies for reducing Firebase costs.
- **Rule TROUBL-3.4**: Create a guide for monitoring and alerting setup.